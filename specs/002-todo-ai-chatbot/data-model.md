# Data Model: Todo AI Chatbot

**Feature Branch**: `002-todo-ai-chatbot`
**Date**: 2026-01-22
**Status**: Design Complete

## Overview

This document defines the data model extensions for Phase 3 AI Chatbot integration. These models extend the existing Phase 2 schema (User, Task) without modifications to existing tables.

---

## Entity Relationship Diagram

```
┌─────────────────┐
│      User       │
│─────────────────│
│ id (UUID, PK)   │
│ email           │
│ hashed_password │
│ created_at      │
└───────┬─────────┘
        │
        │ 1:1 (one conversation per user)
        │
        ▼
┌──────────────────────┐
│    Conversation      │
│──────────────────────│
│ id (UUID, PK)        │
│ user_id (UUID, FK)   │──── UNIQUE constraint
│ created_at           │
│ updated_at           │
└───────┬──────────────┘
        │
        │ 1:N (many messages per conversation)
        │
        ▼
┌──────────────────────────┐
│        Message           │
│──────────────────────────│
│ id (UUID, PK)            │
│ conversation_id (FK)     │
│ role (user|assistant|tool│
│ content (TEXT)           │
│ tool_call_id (nullable)  │
│ tool_name (nullable)     │
│ created_at               │
└──────────────────────────┘
```

---

## Entities

### 1. Conversation

Represents a chat session for a user. One conversation per user (simplifies UX).

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique identifier |
| `user_id` | UUID | FOREIGN KEY → user(id), UNIQUE, NOT NULL, ON DELETE CASCADE | Owner of conversation |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last activity timestamp |

**Indexes**:
- `idx_conversation_user` on `user_id` (unique constraint creates implicit index)

**Relationships**:
- Belongs to: `User` (many-to-one)
- Has many: `Message` (one-to-many)

**SQLModel Definition**:
```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional, List

class Conversation(SQLModel, table=True):
    __tablename__ = "conversation"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="user.id", unique=True, nullable=False, index=True)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)
    updated_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)

    # Relationships
    user: "User" = Relationship(back_populates="conversation")
    messages: List["Message"] = Relationship(back_populates="conversation", sa_relationship_kwargs={"cascade": "all, delete-orphan"})
```

---

### 2. Message

Individual chat message within a conversation. Stores user messages, assistant responses, and tool execution records.

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | Unique identifier |
| `conversation_id` | UUID | FOREIGN KEY → conversation(id), NOT NULL, ON DELETE CASCADE | Parent conversation |
| `role` | VARCHAR(20) | NOT NULL, CHECK IN ('user', 'assistant', 'tool') | Message sender role |
| `content` | TEXT | NOT NULL | Message content |
| `tool_call_id` | VARCHAR(50) | NULLABLE | OpenAI tool_call_id for tool responses |
| `tool_name` | VARCHAR(50) | NULLABLE | Name of tool that was called |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Creation timestamp |

**Indexes**:
- `idx_message_conversation` on `conversation_id`
- `idx_message_created_at` on `created_at`

**Relationships**:
- Belongs to: `Conversation` (many-to-one)

**Role Values**:
- `user`: Message sent by the human user
- `assistant`: Response generated by the AI agent
- `tool`: Result of a tool execution (e.g., add_task, list_tasks)

**SQLModel Definition**:
```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional
from enum import Enum

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    TOOL = "tool"

class Message(SQLModel, table=True):
    __tablename__ = "message"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    conversation_id: UUID = Field(foreign_key="conversation.id", nullable=False, index=True)
    role: MessageRole = Field(nullable=False)
    content: str = Field(nullable=False)
    tool_call_id: Optional[str] = Field(default=None, max_length=50)
    tool_name: Optional[str] = Field(default=None, max_length=50)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False, index=True)

    # Relationships
    conversation: "Conversation" = Relationship(back_populates="messages")
```

---

## Validation Rules

### Conversation
- `user_id` must reference an existing user
- Only one conversation allowed per user (UNIQUE constraint)
- `updated_at` should be updated on any new message

### Message
- `role` must be one of: 'user', 'assistant', 'tool'
- `content` cannot be empty for user/assistant roles
- `tool_call_id` and `tool_name` should both be set for tool role messages
- `tool_call_id` and `tool_name` should be NULL for non-tool messages
- Messages are immutable after creation (no updates)

---

## State Transitions

### Conversation Lifecycle
```
                    ┌─────────────┐
    User opens      │             │
    chatbot    ────►│   Created   │
                    │             │
                    └──────┬──────┘
                           │
                           │ First message
                           ▼
                    ┌─────────────┐
                    │             │
                    │   Active    │◄───┐
                    │             │    │ Each message
                    └──────┬──────┘    │ updates
                           │           │ updated_at
                           └───────────┘
```

### Message Creation Flow
```
User Message:
  1. Create Message(role='user', content=user_input)
  2. Save to database

AI Processing:
  3. Load conversation history
  4. Run agent with tools
  5. If tool called:
     - Create Message(role='tool', tool_name=..., tool_call_id=..., content=result)
  6. Create Message(role='assistant', content=ai_response)

All saved atomically (single transaction)
```

---

## Database Migration

### SQL Migration Script
```sql
-- Migration: 003_add_chat_tables.sql
-- Description: Add Conversation and Message tables for AI chatbot

BEGIN;

-- Create conversation table
CREATE TABLE conversation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    CONSTRAINT uq_conversation_user UNIQUE (user_id)
);

-- Create message table
CREATE TABLE message (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID NOT NULL REFERENCES conversation(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'tool')),
    content TEXT NOT NULL,
    tool_call_id VARCHAR(50),
    tool_name VARCHAR(50),
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_message_conversation ON message(conversation_id);
CREATE INDEX idx_message_created_at ON message(created_at);

-- Add constraint: tool fields must be consistent
ALTER TABLE message ADD CONSTRAINT chk_tool_fields
    CHECK (
        (role = 'tool' AND tool_name IS NOT NULL) OR
        (role != 'tool' AND tool_name IS NULL AND tool_call_id IS NULL)
    );

COMMIT;
```

### Rollback Script
```sql
-- Rollback: 003_add_chat_tables.sql

BEGIN;

DROP TABLE IF EXISTS message;
DROP TABLE IF EXISTS conversation;

COMMIT;
```

---

## Query Patterns

### Get or Create Conversation for User
```python
def get_or_create_conversation(session: Session, user_id: UUID) -> Conversation:
    conversation = session.exec(
        select(Conversation).where(Conversation.user_id == user_id)
    ).first()

    if not conversation:
        conversation = Conversation(user_id=user_id)
        session.add(conversation)
        session.commit()
        session.refresh(conversation)

    return conversation
```

### Load Recent Messages (Context Window)
```python
def get_recent_messages(
    session: Session,
    conversation_id: UUID,
    limit: int = 20
) -> List[Message]:
    return session.exec(
        select(Message)
        .where(Message.conversation_id == conversation_id)
        .order_by(Message.created_at.desc())
        .limit(limit)
    ).all()[::-1]  # Reverse to chronological order
```

### Save Chat Turn (User + Assistant + Tools)
```python
def save_chat_turn(
    session: Session,
    conversation_id: UUID,
    user_message: str,
    assistant_response: str,
    tool_calls: List[dict] = None
) -> List[Message]:
    messages = []

    # User message
    user_msg = Message(
        conversation_id=conversation_id,
        role=MessageRole.USER,
        content=user_message
    )
    messages.append(user_msg)

    # Tool calls (if any)
    if tool_calls:
        for tc in tool_calls:
            tool_msg = Message(
                conversation_id=conversation_id,
                role=MessageRole.TOOL,
                content=tc["result"],
                tool_call_id=tc["id"],
                tool_name=tc["name"]
            )
            messages.append(tool_msg)

    # Assistant response
    assistant_msg = Message(
        conversation_id=conversation_id,
        role=MessageRole.ASSISTANT,
        content=assistant_response
    )
    messages.append(assistant_msg)

    # Save all in single transaction
    session.add_all(messages)

    # Update conversation timestamp
    conversation = session.get(Conversation, conversation_id)
    conversation.updated_at = datetime.utcnow()

    session.commit()
    return messages
```

---

## Relationships with Existing Entities

### User Model Extension
Add relationship to existing User model:

```python
# In app/models/user.py - add to existing User class
from typing import Optional

class User(SQLModel, table=True):
    # ... existing fields ...

    # Add relationship (optional, for convenience)
    conversation: Optional["Conversation"] = Relationship(back_populates="user")
```

### No Changes to Task Model
The Task model remains unchanged. Tools interact with tasks through the existing service layer, not through direct model relationships.

---

## Data Retention

### Conversation History
- No automatic deletion (retained indefinitely)
- User can clear history via `DELETE /api/chat/history` endpoint
- Cascade delete removes all messages when conversation deleted
- User account deletion cascades to conversation and messages

### Storage Estimates
- Average message: ~500 bytes
- 50 messages/user/month: ~25KB/user/month
- 1000 active users: ~25MB/month
- Acceptable for Neon free tier

---

## Constitution Compliance

| Principle | Compliance |
|-----------|------------|
| IV. User Isolation | ✅ Conversation has user_id FK, all queries scoped |
| VIII. Stateless Recovery | ✅ All context in database, no server state |
| Consistency | ✅ SQLModel definitions match SQL schema |
| Security | ✅ Cascade deletes, FK constraints, no orphan data |
